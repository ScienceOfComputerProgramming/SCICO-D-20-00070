\documentclass{mproj}
\usepackage{graphicx}
\graphicspath{ {./images/} }

\usepackage{url}
\usepackage{fancyvrb}
\usepackage[final]{pdfpages}
\usepackage{times}

\usepackage[newfloat]{minted}
\setminted[python]{fontsize=\footnotesize}


\usepackage{tcolorbox}
\usepackage{caption}

\BeforeBeginEnvironment{minted}{\begin{tcolorbox}[colframe=white!25!white]}%
\AfterEndEnvironment{minted}{\end{tcolorbox}}%

\newenvironment{code}{\captionsetup{type=listing}}{}
\SetupFloatingEnvironment{listing}{name=Code Snippet}

% for alternative page numbering use the following package
% and see documentation for commands
%\usepackage{fancyheadings}


% other potentially useful packages
%\uspackage{amssymb,amsmath}
%\usepackage{url}
%\usepackage{fancyvrb}
%\usepackage[final]{pdfpages}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Source Control Integrated Issue Tracking - The Next Generation of Issue Tracking}
\author{Nystrom Johann Edwards}
\date{7th September, 2018}
\maketitle
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
Two areas in which software engineering tools overlap are in issue tracking systems (ITS) and version control systems (VCS). Maintaining both systems is cumbersome and can reduce productivity if focus is constantly switched from developing code to maintaining the issue tracker. This project exemplifies the benefits of combining both tools to reduce the friction between both activities. It shows that the next generation of issue trackers can utilise the power of VCS such that developers can embed issues directly into source code. This combined benefit provides an accurate description of the state of any software project by providing one source of truth. Using the Source Control Integrated Issue Tracking (SCIIT) system we aim to eliminate the friction by extending the VCS and managing issues embedded within the source code. Developers can now update issue information, track development progress, manage collaboration, and inspect complex relationships between their issues and source code as issues are attached to commits.  

Keywords: Issue Tracking, Version Control System, Embedded Issues, Source Code, Git
\end{abstract}

\pagenumbering{roman}
\educationalconsent
\newpage

\section*{Acknowledgements}

I would like to thank my supervisor, Dr Timothy Storer for exposing me to new software engineering possibilities through this project, for his advice and mentoring on creating a new and useful software tool, and most importantly for assistance in making the difficult decisions on design choices.

I would like to thank my wife Virginia for her support and encouragement throughout my programme and all her efforts to ensure that it was completed with great success. I would not have gotten this far without her valuable insight into my projects, her motivational speeches and her uplifting presence.

I am especially grateful to my sister Zophia who has financed my programme and has always believed in supported and encouraged my software development talent. She will always be one of my greatest supporters.

I am grateful to my mother Joslyn and all other members of my family that have invested in my education and encouraged me in this undertaking. Thier efforts will always be greatly appreciated.

Finally, I would like to thank my colleagues at the university that helped in the evaluation of the project that provided feedback needed to make a good solution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}\label{intro}

\pagenumbering{arabic}
\section{Background}

\section{Contribution}

\section{Structure}

%Present state of the art software project issue tracking tools, such as GitHub, GitLab, and JIRA store issues in a database alongside the version control repository that contains the project's source code. This creates friction in development efforts because software developers must remember to keep both the issue tracker and the version control repository up to date as progress is made on completing tasks.

There are many tools used by software engineers in order to create high quality, high performance and maintainable software products. These tools are used by various levels within an organisation in order to coordinate efforts to this end. As such, they are exposed to a wide range of persons collaborating to meet this goal.

Issue tracking systems is at the fore front of collaborating tools when it comes to software development. Bertram (2010) argues that it is used by various groups of persons in order to have a common point of knowledge when it comes to the product that is being developed \cite{Bertram:2010}. For developers in particular the issue tracking system is used as a means to store information on development tasks. Tasks may include, the development of a new feature, the discovery of a bug, the preparation for a release, among others. When progress is made on these tasks it is recorded in the tracker and it provides key information to managers and the team what has taken place.

Version control systems by comparison allow for a similar type of collaboration, however at its core it is the working progress of the entire development of the software product. Here we see the overlap of the two systems where one is related to the product as a working growing artifact and the other as a planning and knowledge base on segments of the software product. Integrating the two systems would potentially provide the benefit of keeping track of both types of critical information in a format that does not duplicate work efforts.

We propose to introduce developers to an extension of the version control system that allows for the tracking of issues as a first step in testing this theory. It is expected that a tool such as this will allow developers to remain highly collaborative on issues and productive on writing code into version control thereby reducing the friction of maintaining two systems and switching focus during development.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Analysis}\label{analysis}

%Has the student surveyed relevant literature and existing software products? Has he/she captured the requirements? Has he/she analysed the problem, and devised a suitable approach for solving the problem?

% talk about the problems faced by developers maintaining both

% talk about the proiority of one over the other

% talk about the overlapping qualities of both systems

% talk about the potential benefits

% talk about what is required in order to aliviate the friction while maintaining productivity

\section{The Problem}

\section{Related Work}  % or literature servey

% talk about what persons have done in order to reduce friction

\section{Related Products}

There are many products on the software market that claim to integrate aspects of the VCS with the ITS. Some boldly claim that they are indeed integrated. Reasearch however suggests that those products while able to draw reference from the VCS, are not designed as an integrated product. There are many products claiming such, however, we will focus on GitLab and Fossil as guiding examples.

GitLab does provide users some integration with its ITS and VCS. Using hastag references within commit messages, developers can mention work done on an issue. This method is cumbersome as it forces developers to remember issue id numbers and does not eliminate or reduce the need for them to access the ITS to view changes to the issue description, comments and disscussions on the issue itself.

Fossil boasts that it is a Distributed VCS with and integrated bug tracker. This claim is somewhat correct as the entire product is simply one executable binary. The bug tracker however is centralised sqlite database of immuatble issues access and managed through a local web interface. There is no way to link commit progress with bugs and the bug tracker itself is no different from others.

Where other project have been marketed as intergated, SCIIT will truly be a novel solution. 

\section{Key Concerns}


\section{Objectives}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Design}\label{design}

This chapter discusses the two main categories of design decisions necessary to integrate ITS and VCS and its result. Firstly is the choice of VCS which is critical for the success of the integration and must contain options allowing it to be extended and manipulated. Secondly is the designs for integrating an ITS that give the ability to leverage the versioning functions of the VCS. Next the chapter discusses the resulting distributed ITS which is differs from the traditional centralised design. Then it ends with a layout of the software architecture.




\section{The Git Version Control System}

For this project it is necessary to pick a VCS that is easily extended. Git the open source VCS was used as the backbone of the new system. As the most popular open source VCS  technology to date, it offers the opportunity to attain vast amounts of information on its internal mechanisims in order to extend it to include custom functionalities such as an issue tracker. The documentation of Git and the wide variety of related products, articles and examples gives insight into how it is extended. A discussion on its revision control architecture sheds insight on what can be manipulated.



%In order to achieve such a task, embedded issues are extracted from the source code commits in the VCS.
\subsection{Git's Version Control Architecture}

Git's architechture is primarily based on a series of references or pointers to objects which are updated when new changes to files are checked in to the VCS. In Git each revision of a group of files is called a commis. In each commit, files are stored as a compressed versions of the entire file contents called blobs and maintained in a folder structure by trees. When new commits (additions, modification and deletions) to files are found, Git saves the compressed blobs to its objects directory and creates a new reference by hashing the blob's contents. These references are known as \textit{sha} references. 

To keep track of the blobs, references to them are assigned to trees which represent either the folder containing the blob or the root folder of the entire project.  The root project folder tree is then in turn referenced to the commit. This way every commit made represents the full state of the software project during development. The series of references from blobs to trees and trees to commits are the main mechanism for identifying revisions to files. To determine the files that were changed it is now just a matter of comparing new hashes of file contents to the corresponding older references.

Since the architecture is based on the assigning and changing of references or pointers, an ITS can be embedded into VCS by assigning references and pointers to objects containing issue information. This way each commit will reference a group of issues. The next section discusses how this can be achieved and how we can embedded the information in source code.
% talk about how we embed issues into the source code





\section{Integrating an Issue Tracker System}


\subsection{Embedding Issues into Source Code}

After understanding the architecture of Git, the next step of integration is to find a way to store issues alongside commits. This is achieved by embedding the issue and its related information into the source code of the software project files as a block comment. The only mandatory requirement for embedding and issue is to provide an issue id using an \textbf{\textit{@issue}} flag. All other information can be optional or supplied in later commits. Code Snippet \ref{snip:embedded-issue} shows the format of an issue with all optional information in a python code block.

\begin{code}
\label{snip:embedded-issue}
\captionof{listing}{Example of an embbed issue in python}
\begin{minted}{python}
"""
    @issue signin
    @title Create a signin page
    @description
      Create a signin page for users of the website. 
      Include social signin and terms and conditions acceptance.
    @assigned to nystrome, kevin, daniels
    @due date 12 Oct 2018
    @label design, ui
    @weight 6
    @priority high    
"""
\end{minted}
\end{code}




\subsection{Issue Repository and References}

% describe how issues are stored and managed
Issues embedded into source code can now be extracted into thier own repository. To achieve this, SCIIT follows the same principle of using references for issues as Git does for revision objects however, references are assigned to issue objects differently. When a commit is created, the system reads the changes to the source code in that commit and identifies the existence of embedded issues. The contents or information of the embebbed issue is extracted and used to form its sha reference. All the issues identified are then cached to a separate issue repository on the file system for quicker access. 

All issue references that were identified beloning to that commit are then collectively assigned to an issue tree. Unlike Git, SCIIT contains just one issue tree per commit. This keeps the SCIIT disk space usage on the file system as small as possible since the creation of may file objects add disk space overheads. Consequentially, any commits that do not contain issues point to the same empty issue tree object. Finally, any issues that have not been changed over time are continually referenced on to the next commit.

Each individual issue tree reference is then referenced to a special object called an issue commit. For all intents and purposes, they contain the reference to a Git commit and a reference to an issue tree. This way they represent both the ITS and VCS creating one system that manages both activities. 




\subsection{The Integrated System}

As a result of the previous designs, a Source Control Integrated Issue Tracking (SCIIT) System can now be adequately used to represent the complex relationships between the management of issues and the state of the software project. Figure \ref{fig:sciit-filesystem} shows how SCIIT integrates the ITS alonside the VCS on the file system as a series references when commits are created.

\begin{figure}[t]
\caption{SCIIT ITS to VCS Filesystem Design}
\label{fig:sciit-filesystem}
\centering
\includegraphics[width=10cm]{sciit-filesystem}
\end{figure}

Figure \ref{fig:sciit-filesystem} shows that every commit made in Git generates an issue commit that contains references to all the changes made to those issues. This therefore poses a change in the traditional management of issues. If an issue is changed by editing the issue data embedded in the soruce code as a comment then a new issue object is created and assigned to a new issue tree. Changes to the references of an issue object over time can now be associated with a change in the issue. The issue tracker also intuitively determines if issues are closed by removing references to an issue that has been deleted from the embedded comment.

% how it works in a distributed environment








\section{SCIIT's Distributed ITS}

%be explicit
As a result of integration the system operates in a distributed environment since the backbone of the system is based on a distributed VCS. In Git, this involves the use of branching in which two different series of commits have deviated from one prior commit. Developers can spawn and work in new branches that are parallel to others. When complete they merge their changes with other branches. There are also remote Git repositories on servers where commits on branches are pushed and pulled to and from the local machine. 

Although branching and merging, pushing and pulling are the main mechanisims allowing Git to be distributed, they all are based on the same primative object, the commit. Since the issue tracker is based on this primative object, a branch commit will contain issue commits, issue trees and issues which may change over time. The utility of this design allows for the issue tracker to also be distributed.

% for eval ++> The design concept gets compounded in merging senarios. In such events, developers can now be alerted by the VCS that there is a conflict with issues as source code are compared. At this point developer team members can decide in their merges what changes should be made to the issue. Merge points also create commit objects which the SCIIT system will again scan for embedded issues and update the issue references.

\begin{figure}[t]
\caption{Distributed Issue Tracking}
\label{fig:distributed-issue-tracking}
\centering
\includegraphics[width=10cm]{distributed-issue-tracking}
\end{figure}

Figure \ref{fig:distributed-issue-tracking} shows a practical example of the distributed ITS. At point 1 a new issue is added for the first time into the orange branch. Commits that follow this keep the reference the to issue created here until a user modifies the embedded issue information or removes it from the source code. When branching to green, issue 1 remains open in both branches. At point 2 another issue is created. Here there are two issues open on the green branch and one open on the orange. The purple branch inherits both issues from the green branch. At point 3, developers make the decision to merge issue 2 into the orange branch. At point 4, both issue 1 and 2 are closed by deleting the embedding from the source code. Here there are no issues on the purple branch. At point 5, developers decide that the work has actually been completed and resolves the merge conflict by deleting the two issue embeddings from the source code. This shows the distributred nature of issues.







\section{Software Architecture}

Figure \ref{fig:sciit-software-arch} shows the software architecture of SCIIT. There are two seperate file system storage at the heart. One responsible solely for the VCS information and the other for issues. The VCS information is accessed by the higher level tool Git which in term can be manipulated by the GitPython Library. The SCIIT Library has direct access to the issue repository and is responsible for managing all the objects stored within that context. Git hooks allow for the Git application to call on functions of the SCIIT Library when commit, merge, pull and checkout events take place. All combined these components make up the SCIIT system which allows for the manipulation of VCS and ITS objects.


\begin{figure}[t]
\caption{SCIIT Software Architecture}
\label{fig:sciit-software-arch}
\centering
\includegraphics[width=10cm]{sciit-software-arch}
\end{figure}





\section{Summary}

This chapter shows the design of a Source Code Integrated Issue Tracker and how it can be developed to utilise the power of both ITS and VCS. The benefit of which is to allow developers to focus on what they know and deal with the best which is source code. They are now less burdened with the resposibility of diligently maintaining an ITS as all the issues are now embedded into the VCS  commits. This should now reduce the friction between maintaining and issue tracker and developing code as the activities are combined and automated. The next chapter will discuss the impact that such a system will have on the developer, developer teams, and project activities.









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}\label{implementation}

This chapter discusses the implementation of the design for providing mechanisms to interact with the integrated ITS. These are the use of Git Hooks for performing issue extraction at certain Git events; the extension of the GitPython open source library to manipulate Git object, Git commands and managing the Issue Repository; and the interfaces required to view and manage ITS information. The chapter continues by showing how issue tracking is performed and concludes outlining the challenges faced.

\section{Mechanisms}

\subsection{GitPython}

One of the three main mechanisms of SCIIT is this extended open source library that enables the manipulation of the Git repository and the Issue Repository. Funtionality in the GitPython library that are related directly to the Git repository are extended to provide the extra functionality needed for managing issues. Two programming library objects in particular are extended; the "Repository" object which allows for manipulating the Git repository and the "BaseObject" object allows for manipulating the raw Git objects (commits, trees, and blobs). Added to these were the ability to manipulate issues, issue trees, issue commits, and the issue repository.

% integrating git with sciit allows for the inference of many pieces of information required by issue trackers

\subsection{Git Hooks}

Git hooks are the second main mechanism that allows for the handling of issues. In this project three hooks in particular are utilised; the post-commit, post-merge, and post-checkout. The post-commit hook comminicates with the SCIIT library in order to search for embeddings and create issues in the ITS for every commit made. This hook reduces the friction of the programmer having to switch focus to the issue tracker at this point to update issue information or status. Just one activity is required to do both. The post-merge hook is utilised during two Git events; merging and pulling. In order for SCIIT to be useful to teams, the issues that other developers create must be syncronised between all members of the team. When pulling down the VCS from the remote repository, SCIIT will then build the issue objects for the difference of commits on the local machine and the remote. This allows all on the team to collaborate on the same issues. Similarly, during a merge, the repository is syncronised to ensure that all commits have the correct issue references. The post-checkout hook is similar to the merge in that it syncronises issue references with commits. This is particularly implemented for the users that just fetch Git commits from the remote to checkout at a later stage.

\subsection{Interfaces}

The last main mechanism of the SCIIT system is its interface channels. There are three interface channels that provide three different services. 

The first is a command line interface. The CLI does not allow for direct manipulation of issues but it allows for users to refresh the issue repository, view individual issues and view issue tracker. The initialisation commmand creates the issue repository and builds issue objects from past commits. This is essential for Git since developers can work on software projects that already exist. The developers can clone a project and then initialise the issue tracker by building all the issue references that were embedded in the commits. Initialisation also sets up the Git hooks required for the project to be able to track new issues. 

There is a command for viewing the tracker. This allows for user to see the status of all issues in the issue tracker. It also shows the complex relationships between the ITS and VCS such as participants, creator, commit activities to the issue, changes in description and changes to the issue over time. This command shows the power of integrating ITS and VCS such that complex relationships can be inferred from the issue and version control repository objects. It also allows for showing the state of the issue tracker between revisions of commits that may be on different branches. Futher CLI commands and its uses can be found in Appendex B Figure \ref{fig:sciit-cheatsheet} or screenshoots of the issue tracker can be found in % Appendix C Figure \ref{fig:sciit-tracker-shot1}.

The second is a web interface. This interface shows the issue tracker to the user by lauching a local web browser with all the issue tracking information loaded into html view. Users are not allowed to edit any of the information within this interface but it gives and easier display for users to view their issues, read through issue activity and view all other inferred data which performing developing tasks.

The thrid is an intermediate webservice that allows for the integration of GitLab issues with the SCIIT System. The main reason for having such an interface is that it allows for non developer members of a project such as coaches, team leads, production staff or contributors to create issues in GitLab that will create commits with embedded issues. This module was developed to show that SCIIT and its principles could be integrated with traditional ITS to engage non developer users. The webservice works by using GitLab Webhooks in conjuction with SCIIT on a webserver and the GitLab API as follows:

\begin{itemize}
  \item \textbf{Push Webhooks:} These hooks are triggered when developers push commits to the repository. A HTTP request is then sent to the SCIIT webservice interface. The interface then fetches the changes from the GitLab remote repository as a mirror repository and syncs the Git commits with the ITS issue references. Any new references that are made by these changes are then packaged and requests are made to the GitLab Issues API to create or edit those issues. Commit actitvities related to these changes are added to the GitLab issue as notes.
  \item \textbf{Issue Webhooks:} These hooks are triggered when someone creates or edits an issue in the GitLab web interface. A HTTP request is then sent to the SCIIT webservice interface. The interface then takes the issue title and issue description that was changed and makes changes to the relevant source code contents of the file that corresponds to the issue. If it has not been assigned to a file previously a new file is created to track the new issue. It then makes a request to the GitLab Commits API to create a new commit with the specified changes.
\end{itemize}

When this webservice is attached to the GitLab remote repository, it syncs GitLab issues, SCIIT issues and commits such that the developer need not be concerned that the issues they create or need to work on is not in the SCIIT system. A simple pull from the remote repository will bring in the related commits and refresh the issue tracker and its details.

% talk about the cli used to access the issues after they are created


%As previously discussed in the chapter on design, the issues are cached to the file system. In order to get the issue tracking information out of these object we must build the tracker from 


\section{Issue Tracking}

The embedded issue tracker is no longer similar to the centralised issue trackers that are commonly found. In fact, the SCIIT Issue Tracker is decentralised an depends on the graph structure of branches and commits. It is accessed via one of the interfaces and is built from a revision of the repository. A revision is a range of commits that is reachable from one commit to another. They can also be specified based on Git's intermediate references such as the HEAD or branch names and can span a path which may include all commits or those reachable from this branch.

As a distributed issue tracker, information about the issues are built by traversing the entire repository based on the revision. This is similar to Git operations such as the log where commits are walked through and commit inforation is displayed based on whether the commit is reachable from the revision specified. To build the issue tracker, commits and issue objects on this revision path are read and complex information between the ITS and the VCS are extracted. The following is a list of such information:

\begin{itemize}
    \item \textbf{Creator:} The creator and the date and time of creation can be identified by the first occurance of this embedded issue in the commit revision history. The author and time of that commit provides the exact information that reflects the creator of the issue.
    \item \textbf{Last Author:} The last author and the date and time of authoring can be identified as the last occurance of this embedded issue in the commit revision history. Similarly this provides the exact information required
    \item \textbf{Closed:} Again this information is extracted from the last commit mentioned that does not have the embedded issue. The person that has removed the embedded issue is the person that closed the issue.
    \item \textbf{Participants:} This is a list of persons that made commits that contained these issues. It adequately infers who has done work on the issues.
    \item \textbf{Branch Information:} This information is extracted showing the existance of issues on branches, and their status on branches. It can help the ITS user identify where issues are present and the status of their state.
    \item \textbf{Commit Activities:} This is a list that shows the date, commit message and commit author for every commit that has the issue present. It is one of the more powerful inferrence tools as it can show what work was done on issues over time and gives four main advantages. It represents real changes to the functionality and state of the software product as commits are made. It can contain a commit message the identifies precisely what progress has been made on an issue. It can tell us which developer contributed the change to the issue. It can give us the commit that contains the changes so that it can be reviewed.
\end{itemize}

The information inferred does not need to be explicitly entered into the issue tracker as it does in traditional ITS. This is the power of SCIIT where users need not be concerend about manually recording such information but it can be generated for them. See Appendix C Screenshots % Figure \ref{} and \ref{} which shows the issue tracker in the cli interface and on the web interface.



\section{Challenges}

Since the SCIIT system is first of its kind there would be some challenges associated with its design and development. The following outlines the major design and development challenges
% build time

The first major challenge concerns Git as a light weight system that invloves single threaded file access operations. When building the issue repository from past commits, SCIIT traverses each file object scans its contents to determine if an issue is persent or not. This is a time consuming process and can only be preformed in a single thread. If multiple threads, we will encounter I/O errors, especially since there is a high likelihood that the same file may be accessed or open in many threads. 

This limits the performance of SCITT to build issues from past commits on repositories that consist of a high number of commits such as the Linux Open Source Project or Tensorflow. Also the performace also suffers based on the commit/merge strategy that the developer teams are using since some strategies can have commits that contain a larger tree of file changes that other strategies. 

It also affects the performance of builing the issue tracker history as each object must be read in a single thread and added the the issue tracker history object. For very large repositorys it can take some time for the issue tracker to be built which can reduce the productivity of the developer. The GitLab intergration webservice helps to reduce this issue, however, developer teams may user other services and intergration services for those have not yet been developed. This is the major challenge of the project and its design beacuesr of being based on Git. % See Appendix A on Perfomance Issues

% communicating with webservice
The second major challenge concerns the use of GitLab API calls within the webservice interface. GitLab Webhooks are a part of the main functionality of the website. For example, utilising the GitLab Commits API triggers a Push Webhook. As such, during development special care needed to be taken to verify the dates of receiving GitLab webhooks with the internal webservice time. If a Webhook was triggered and came in within seconds of another they would be ignored as it would have originated from API calls within the webservice. In our webservice handling Issue Hooks generated requests for handling Push Hook and vice versa. If this was not carefully handled internally then the webservice would be in an infinate loop creating GitLab Issues and commit on the repository.








%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}\label{evaluation}

This project provides a great contribution to reducing the friction between ITS and VCS developer activities. It does however propose so radical changes to the method in which issue tracking is currently performed. As such this section will evaluate SCIIT as it relates to current ITS practices, highlight benefits achieved, and show the robustness of the product itself.

% These three hooks ensure that the ITS issues stays in reference to the VCS commits. It also shows that the end user does not need to be concerend about

%for eval section ==>> In a traditional sense however, issue trackers are meant to be a centralised system. Also if we consider that work is being done on a branch we should be able to capture all the information for all issues on all branches without conflicting data. Fortunately, Git also allows for the querying of revisions such that all commits on all branches are returned maintaing thier parental links. The next chapter describes how this was implemented in order to maintain the valuable issue information on all branches.


% highlight the benefits achieved by the design

%for eval section ==>> By maintaining issues in this manner we can see that a significant step has been taken to reduce the friction between the two development activities of maintaining the ITS and VCS. Developer now need only concern themselves with pulling, and pushing code to the repository where the issue tracker will seemlessly build, track and maintain issues in the background. This does not mean that developers are not resposible for looking at the embedded issues and performing the task it requires to implement them. However, it allows them to work in an environment with one point of contact. The design of SCIIT allows for developers to trod along writing code and to care for the issue tracking process. Additionally the issue tracker will now be up to date with the state of each revision of the source code.

\section{Testing} % should I bother having a testing section

This section describes in detail the testing that was used to verify the design and validity of the system output. The system's software tests verify that functional and integration units opperate as designed. During testing any unexpected behaviour encounted caused changes to the broken functions to ensure that the final product did not contain any bugs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}\label{conclusion}

This project shows that Issue Tracking Systems can be successfully embedded into Version Control Systems to reduce the friction between them during the software development process. The solution is a Source Control Integrated Issue Tracking (SCIIT) system that saves issues alongside commits together in a distributed VCS.

\section{Future Work}

% the impact on git workflows

% the impact on non developer use

% the impact on global software engineering

\appendix % first appendix
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Performance Issues}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Additional Diagrams}
\begin{figure}[h!]
\caption{SCIIT Command Line Interface Cheatsheet}
\label{fig:sciit-cheatsheet}
\centering
\includegraphics[width=16cm]{Cheatsheet}
\end{figure}

%consider making a diagram for the sciit webservice

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Screenshots}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Development Strategy}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% it is fine to change the bibliography style if you want
\bibliographystyle{plain}
\bibliography{mproj}
\end{document}
